// s print Printable Struct: num1: 10 num2: 20
str :: $import "String.apoc";
$import "Basic.apoc";


fn main() -> i32 {

	s: Test_Struct;
	s.a[43] = 10;
	b: [512]i32;


	size := 512;
	a0 := #*u32 @s.a;
	a1 := #*u32 @b;
	for ; size > 16 ; {
		a0[0] = a1[0];	
		a0[1] = a1[1];	
		a0[2] = a1[2];	
		a0[2] = a1[3];	

		a0 += 4;
		a1 += 4;
		size -= 16;
	}

	for ; size > 4 ; {
		*a0 = *a1 ;
		a0 += 1;
		a1 += 1;
		size -= 4;
	}

	c0 := #*u8 a0;
	c1 := #*u8 a1;
	for ; size > 0 ; {
		*c0 = *c1;
		c0 += 1;
		c1 += 1;
		size -= 1;
	}
	str.print("asd", 10);
	-> 0;
}
// @TODO: bugs

struct Test_Struct {
	a: [1024]i32;
}

/*

fn main() -> i32 {
	// @TODO: var arg overloaded functions don't work
	// @TODO: var arg overloaded functions don't work
	// @TODO: var arg overloaded functions don't work
	str.print("asd", 10);
	size := 4349;
	a0 := #*u32 0;
	a1 := #*u32 12390;
	for ; size > 16 ; {
		a0[0] = a1[0];	
		a0[1] = a1[1];	
		a0[2] = a1[2];	
		a0[2] = a1[3];	

		a0 += 4;
		a1 += 4;
		size -= 16;
	}

	for ; size > 4 ; {
		*a0 = *a1 ;
		a0 += 1;
		a1 += 1;
		size -= 4;
	}

	c0 := #*u8 a0;
	c1 := #*u8 a1;
	for ; size > 0 ; {
		*c0 = *c1;
		c0 += 1;
		c1 += 1;
		size -= 1;
	}
	str.print("asd", 10);
	-> 0;
}

fn print_printable_struct(the_struct: *void) -> str.string {
	casted := #*Printable_Struct the_struct;
	-> str.format_args("Printable Struct: num1: % num2: %", casted.num1, casted.num2);
}

struct Printable_Struct {
	num1: i32;
	num2: i32;
}
*/

