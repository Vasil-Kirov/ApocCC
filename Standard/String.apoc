
STRING_BUFFER_SIZE :: 256;

struct string
{
	text:* u8;
	len:   i64;
}

struct String_Builder
{
	buffer:[256] u8;
	len: i64;
	next:* String_Builder;
}

func builder_to_string(builder: *String_Builder) -> string
{
	out := string {};
	out_len := 0;
	current := builder;
	for i := 0; current.next != null; ++i {
		out_len += current.len;
		current = current.next;
	}
	out_len += current.len;
	out.text = mem_alloc(#u64 out_len);
	out.len = out_len;

	times := 0;
	for i := 0; current.next != null; ++i {
		copy(@out.text[times * STRING_BUFFER_SIZE], @current.buffer[0], #u64 current.len);
		current = current.next;
		times += 1;
	}
	copy(@out.text[times * STRING_BUFFER_SIZE], @current.buffer[0], #u64 current.len);
	out_len += builder.len;
	-> out;
}

func init_builder(text: *u8) -> String_Builder
{
	out := String_Builder{};
	out.len += 1;
	current := @out;
	times := 0;
	for i := 0; text[i + times * STRING_BUFFER_SIZE] != 0; ++i {
		current.buffer[i] = text[i + times * STRING_BUFFER_SIZE];
		current.len += 1;
		if i == STRING_BUFFER_SIZE {
			i = 0;
			times += 1;
			current.next = mem_alloc($size String_Builder);
			current = current.next;
		}
	}
	-> out;
}

overload [](str: string, index: i64) -> u8
{
	-> str.text[index];
}

overload +(str: string, text:* u8) -> string
{
	out: string;
	text_len := #i64 len(text);
	out.len = str.len + text_len;
	out.text = mem_alloc(#u64 out.len);
	copy(out.text, str.text, #u64 str.len);
	copy(@out.text[str.len], text, #u64 text_len);
	-> out;
}

overload +=(str: *String_Builder, text:* u8)
{
	text_len := len(text);
	times := text_len / str.len;
	current := str;
	for i := 0; i - 1 < times; ++i {
		copy_size := text_len;
		if copy_size > STRING_BUFFER_SIZE copy_size = STRING_BUFFER_SIZE;
		copy(@current.buffer[current.len - 1], @text[i * STRING_BUFFER_SIZE], #u64 copy_size);
		current.len += copy_size;
		text_len -= STRING_BUFFER_SIZE;
		current = current.next;
	}
	
}

called := 0;
overload +=(str: *String_Builder, c: u8)
{
	to_put := str;
	for ; to_put != null && to_put.len == STRING_BUFFER_SIZE; null {
		if to_put.next == null  {
			to_put.next = #*String_Builder mem_alloc($size String_Builder);
		}
		if to_put.len == STRING_BUFFER_SIZE
			to_put = to_put.next;
	}
	to_put.buffer[to_put.len] = c;
	to_put.len += 1;
}

overload ==(str: string, text:* u8) -> bool
{
	str2 := string { text, len(text) };
	-> compare(str, str2);
}

func compare(str1: string, str2: string) -> bool
{
	if str1.len != str2.len
		-> false;

	for i := 0; i < str1.len; ++i
		if str1.text[i] != str2.text[i] -> false;
	-> true;
}

func to_string(text:* u8) -> string
{
	text_len := len(text);
	allocated := mem_alloc(#u64 text_len);
	copy(allocated, text, #u64 text_len);
	str := string { allocated, text_len };
	-> str;
}

func terminate_string(str: string) -> string
{
	out: string;
	out.len = str.len + 1;
	out.text = mem_alloc(#u64 out.len);
	copy(out.text, str.text, #u64 str.len);
	out.text[out.len] = 0;
	-> out;
}


func parse_format(format: string, list:* Any) -> string
{
	builder := init_builder("");
	list_index := 0;
	for i := 0; i < format.len; ++i {
		if format[i] == '%' {
			item := list[list_index];
			list_index += 1;
		} else {
			builder += format[i];
		}
	}
	builder += #u8 10;
	out := builder_to_string(@builder);
	-> out;
}

func print(format:* u8)
{
	str := to_string(format);
	list:* Any;
	var_arg_start(@list);
	out := parse_format(str, list);
	var_arg_stop(@list);
	stdout := get_stdout();
	write_file(stdout, #*u8 out.text, #u32 out.len);
}

func print(format: string, ...)
{
	list:* Any;
	var_arg_start(@list);
	out := parse_format(format, list);
	var_arg_stop(@list);
	stdout := get_stdout();
	write_file(stdout, #*u8 out.text, #u32 out.len);
}


func copy(dst:* void, src:* void, size: u64)
{
	a0 := #*u8 dst;
	a1 := #*u8 src;
	for i := 0; i < #i64 size; ++i
	{
		a0[i] = a1[i];
	}
}

func len(text:* u8) -> i64
{
	result := 0;
	for result = 0; text[result] != 0; ++result {}
	-> result;
}
