
STRING_BUFFER_SIZE :: 256;

struct string
{
	text:* u8;
	len:   i64;
}

struct String_Builder
{
	buffer:[256] u8;
	len: i64;
	next:* String_Builder;
}

func builder_to_string(builder: *String_Builder) -> string
{
	out := string {};
	out_len := 0;
	current := builder;
	for i := 0; current.next != null; ++i {
		out_len += current.len;
		current = current.next;
	}
	out_len += current.len;
	out.text = mem_alloc(#u64 out_len);
	out.len = out_len;

	times := 0;
	for i := 0; current.next != null; ++i {
		copy(@out.text[times * STRING_BUFFER_SIZE], @current.buffer[0], #u64 current.len);
		current = current.next;
		times += 1;
	}
	copy(@out.text[times * STRING_BUFFER_SIZE], @current.buffer[0], #u64 current.len);
	printf("len: %d\n", current.len);
	out_len += builder.len;
	-> out;
}

func init_builder(text: *u8) -> String_Builder
{
	out := String_Builder{};
	out.len += 1;
	current := @out;
	times := 0;
	for i := 0; text[i + times * STRING_BUFFER_SIZE] != 0; ++i {
		current.buffer[i] = text[i + times * STRING_BUFFER_SIZE];
		current.len += 1;
		if i == STRING_BUFFER_SIZE {
			i = 0;
			times += 1;
			current.next = mem_alloc($size String_Builder);
			current = current.next;
		}
	}
	-> out;
}

overload [](str: string, index: u64) -> u8
{
	-> str.text[index];
}

overload +(str: string, text:* u8) -> string
{
	out: string;
	text_len := #i64 len(text);
	out.len = str.len + text_len;
	out.text = mem_alloc(#u64 out.len);
	copy(out.text, str.text, #u64 str.len);
	copy(@out.text[str.len], text, #u64 text_len);
	-> out;
}

overload +=(str: *String_Builder, text:* u8)
{
	text_len := len(text);
	times := text_len / str.len;
	current := str;
	for i := 0; i - 1 < times; ++i {
		copy_size := text_len;
		if copy_size > STRING_BUFFER_SIZE copy_size = STRING_BUFFER_SIZE;
		copy(@current.buffer[current.len - 1], @text[i * STRING_BUFFER_SIZE], #u64 copy_size);
		current.len += copy_size;
		text_len -= STRING_BUFFER_SIZE;
		current = current.next;
	}
	
}

overload ==(str: string, text:* u8) -> bool
{
	str2 := string { text, len(text) };
	-> compare(str, str2);
}

func compare(str1: string, str2: string) -> bool
{
	if str1.len != str2.len
		-> false;

	for i := 0; i < str1.len; ++i
		if str1.text[i] != str2.text[i] -> false;
	-> true;
}

func to_string(text:* u8) -> string
{
	text_len := len(text);
	allocated := mem_alloc(#u64 text_len);
	copy(allocated, text, #u64 text_len);
	str := string { allocated, text_len };
	-> str;
}

func terminate_string(str: string) -> string
{
	out: string;
	out.len = str.len + 1;
	out.text = mem_alloc(#u64 out.len);
	copy(out.text, str.text, #u64 str.len);
	out.text[out.len] = 0;
	-> out;
}

func print(str: string)
{
	to_print := terminate_string(str);
	printf(to_print.text);
}

func copy(dst:* void, src:* void, size: u64)
{
	a0 := #*u8 dst;
	a1 := #*u8 src;
	for i := 0; i < #i64 size; ++i
	{
		a0[i] = a1[i];
	}
}

func len(text:* u8) -> i64
{
	result := 0;
	for result = 0; text[result] != 0; ++result {}
	-> result;
}
